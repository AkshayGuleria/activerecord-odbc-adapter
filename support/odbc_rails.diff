Index: lib/active_record/connection_adapters/abstract/schema_definitions.rb
===================================================================
--- lib/active_record/connection_adapters/abstract/schema_definitions.rb	(revision 1)
+++ lib/active_record/connection_adapters/abstract/schema_definitions.rb	(working copy)
@@ -195,7 +195,8 @@
       # Appends a primary key definition to the table definition.
       # Can be called multiple times, but this is probably not a good idea.
       def primary_key(name)
-        column(name, native[:primary_key])
+       # column(name, native[:primary_key])
+       column(name, :primary_key)
       end
 
       # Returns a ColumnDefinition for the column with name +name+.
Index: test/base_test.rb
===================================================================
--- test/base_test.rb	(revision 1)
+++ test/base_test.rb	(working copy)
@@ -44,7 +44,7 @@
 end
 
 class BasicsTest < Test::Unit::TestCase
-  fixtures :topics, :companies, :developers, :projects, :computers
+  fixtures :topics, :companies, :developers, :projects, :computers, :accounts
 
   def test_table_exists
     assert !NonExistentTable.table_exists?
@@ -297,7 +297,15 @@
         Time, Topic.find(1).last_read, 
         "The last_read attribute should be of the Time class"
       )
+    elsif current_adapter?(:ODBCAdapter) && [:ingres, :microsoftsqlserver, :oracle].include?(ActiveRecord::Base.connection.dbmsName)
+      # Above databases don't have a pure date type. (They have a datetime-like type).
+      assert_kind_of(
+        Time, Topic.find(1).last_read, 
+        "The last_read attribute should be of the Time class"
+      )    
     else
+      # ODBCAdapter fails against SQL Server because topics.last_read is 
+      # defined as a datetime column, which is returned as a Ruby Time object.
       assert_kind_of(
         Date, Topic.find(1).last_read, 
         "The last_read attribute should be of the Date class"
@@ -563,7 +571,12 @@
 
   def test_default_values_on_empty_strings
     topic = Topic.new
-    topic.approved  = nil
+    #Sybase does not allow nulls in boolean columns
+    if current_adapter?(:ODBCAdapter) && ActiveRecord::Base.connection.dbmsName == :sybase
+      topic.approved  = false
+    else
+      topic.approved  = nil
+    end
     topic.last_read = nil
 
     topic.save
@@ -572,7 +585,8 @@
     assert_nil topic.last_read
 
     # Sybase adapter does not allow nulls in boolean columns
-    if current_adapter?(:SybaseAdapter)
+    if current_adapter?(:SybaseAdapter) ||
+       current_adapter?(:ODBCAdapter) && ActiveRecord::Base.connection.dbmsName == :sybase
       assert topic.approved == false
     else
       assert_nil topic.approved
@@ -733,7 +747,12 @@
 
   def test_attributes_on_dummy_time
     # Oracle and SQL Server do not have a TIME datatype.
-    return true if current_adapter?(:SQLServerAdapter) || current_adapter?(:OracleAdapter)
+    return true if current_adapter?(:SQLServerAdapter) || 
+        current_adapter?(:OracleAdapter)
+    if current_adapter?(:ODBCAdapter)
+        # Check for databases which don't have a true TIME datatype
+        return true if [:ingres, :oracle].include?(ActiveRecord::Base.connection.dbmsName)
+    end
 
     attributes = {
       "bonus_time" => "5:42:00AM"
@@ -965,7 +984,12 @@
   end
 
   def test_quote
-    author_name = "\\ \001 ' \n \\n \""
+    if current_adapter?(:ODBCAdapter) && [:informix, :sybase].include?(ActiveRecord::Base.connection.dbmsName)
+      #Informix and Sybase only allow printable characters in VARCHAR columns.
+      author_name = "\\ \041 ' \n \\n \""
+    else
+      author_name = "\\ \001 ' \n \\n \""
+    end
     topic = Topic.create('author_name' => author_name)
     assert_equal author_name, Topic.find(topic.id).author_name
   end
@@ -1204,14 +1228,22 @@
     assert xml.include?(%(<content>Have a nice day</content>))
     assert xml.include?(%(<author-email-address>david@loudthinking.com</author-email-address>))
     assert xml.include?(%(<parent-id></parent-id>))
-    if current_adapter?(:SybaseAdapter) or current_adapter?(:SQLServerAdapter)
+    # Following databases don't have a true date type, only a composite datetime type
+    if current_adapter?(:SybaseAdapter) or current_adapter?(:SQLServerAdapter) or
+         current_adapter?(:ODBCAdapter) && 
+         [:ingres,:oracle,:microsoftsqlserver].include?(ActiveRecord::Base.connection.dbmsName)    
       assert xml.include?(%(<last-read type="datetime">#{last_read_in_current_timezone}</last-read>))
     else
       assert xml.include?(%(<last-read type="date">2004-04-15</last-read>))
     end
-    # Oracle and DB2 don't have true boolean or time-only fields
+    # Following databases don't have a true boolean type
+    unless current_adapter?(:OracleAdapter) || current_adapter?(:DB2Adapter) ||
+           current_adapter?(:ODBCAdapter) && 
+           [:ingres,:virtuoso,:oracle,:mysql,:db2].include?(ActiveRecord::Base.connection.dbmsName)
+      assert xml.include?(%(<approved type="boolean">false</approved>)), "Approved should be a boolean"
+    end
+    # Oracle and DB2 don't have a true time-only field
     unless current_adapter?(:OracleAdapter) || current_adapter?(:DB2Adapter)
-      assert xml.include?(%(<approved type="boolean">false</approved>)), "Approved should be a boolean"
       assert xml.include?(%(<bonus-time type="datetime">#{bonus_time_in_current_timezone}</bonus-time>))
     end
   end
Index: test/fixtures/db_definitions/db2.sql
===================================================================
--- test/fixtures/db_definitions/db2.sql	(revision 1)
+++ test/fixtures/db_definitions/db2.sql	(working copy)
@@ -152,7 +152,7 @@
 CREATE TABLE computers (
   id INT GENERATED BY DEFAULT AS IDENTITY (START WITH 10000),
   developer INT NOT NULL,
-  extendedWarranty INT NOT NULL
+  "extendedWarranty" INT NOT NULL
 );
 
 CREATE TABLE posts (
Index: test/fixtures/db_definitions/mysql.sql
===================================================================
--- test/fixtures/db_definitions/mysql.sql	(revision 1)
+++ test/fixtures/db_definitions/mysql.sql	(working copy)
@@ -51,7 +51,7 @@
 CREATE TABLE `projects` (
   `id` int(11) NOT NULL auto_increment,
   `name` varchar(100) default NULL,
-  `type` VARCHAR(255) NOT NULL,
+  `type` VARCHAR(255) default NULL,
   PRIMARY KEY  (`id`)
 ) TYPE=InnoDB;
 
@@ -131,7 +131,7 @@
 ) TYPE=InnoDB;
 
 CREATE TABLE `people` (
-  `id` INTEGER NOT NULL PRIMARY KEY,
+  `id` INTEGER NOT NULL auto_increment PRIMARY KEY,
   `first_name` VARCHAR(40) NOT NULL,
   `lock_version` INTEGER NOT NULL DEFAULT 0
 ) TYPE=InnoDB;
Index: test/fixtures/db_definitions/sybase.sql
===================================================================
--- test/fixtures/db_definitions/sybase.sql	(revision 1)
+++ test/fixtures/db_definitions/sybase.sql	(working copy)
@@ -1,16 +1,16 @@
 CREATE TABLE accounts (
-  id numeric(9,0) IDENTITY PRIMARY KEY,
+  id int IDENTITY PRIMARY KEY,
   firm_id int NULL,
   credit_limit int NULL
 )
 
 CREATE TABLE funny_jokes (
-id numeric(9,0) IDENTITY PRIMARY KEY,
+id int IDENTITY PRIMARY KEY,
   name varchar(50) NULL
 )
 
 CREATE TABLE companies (
-  id numeric(9,0) IDENTITY PRIMARY KEY,
+  id int IDENTITY PRIMARY KEY,
   type varchar(50) NULL,
   ruby_type varchar(50) NULL,
   firm_id int NULL,
@@ -21,13 +21,13 @@
 
 
 CREATE TABLE topics (
-  id numeric(9,0) IDENTITY PRIMARY KEY,
+  id int IDENTITY PRIMARY KEY,
   title varchar(255) NULL,
   author_name varchar(255) NULL,
   author_email_address varchar(255) NULL,
   written_on datetime NULL,
   bonus_time time NULL,
-  last_read datetime NULL,
+  last_read date NULL,
   content varchar(255) NULL,
   approved bit default 1,
   replies_count int default 0,
@@ -36,7 +36,7 @@
 )
 
 CREATE TABLE developers (
-  id numeric(9,0) IDENTITY PRIMARY KEY,
+  id int IDENTITY PRIMARY KEY,
   name varchar(100) NULL,
   salary int default 70000,
   created_at datetime NULL,
@@ -44,7 +44,7 @@
 )
 
 CREATE TABLE projects (
-  id numeric(9,0) IDENTITY PRIMARY KEY,
+  id int IDENTITY PRIMARY KEY,
   name varchar(100) NULL,
   type varchar(255) NULL
 )
@@ -57,14 +57,14 @@
 )
 
 CREATE TABLE orders (
-  id numeric(9,0) IDENTITY PRIMARY KEY,
+  id int IDENTITY PRIMARY KEY,
   name varchar(100) NULL,
   billing_customer_id int NULL,
   shipping_customer_id int NULL
 )
 
 CREATE TABLE customers (
-  id numeric(9,0) IDENTITY PRIMARY KEY,
+  id int IDENTITY PRIMARY KEY,
   name varchar(100) NULL,
   balance int default 0,
   address_street varchar(100) NULL,
@@ -74,7 +74,7 @@
 )
 
 CREATE TABLE movies (
-  movieid numeric(9,0) IDENTITY PRIMARY KEY,
+  movieid int IDENTITY PRIMARY KEY,
   name varchar(100) NULL
 )
 
@@ -84,28 +84,28 @@
 )
 
 CREATE TABLE booleantests (
-  id numeric(9,0) IDENTITY PRIMARY KEY,
+  id int IDENTITY PRIMARY KEY,
   value int NULL
 )
 
 CREATE TABLE auto_id_tests (
-  auto_id numeric(9,0) IDENTITY PRIMARY KEY,
+  auto_id int IDENTITY PRIMARY KEY,
   value int NULL
 )
 
 CREATE TABLE entrants (
-  id numeric(9,0) IDENTITY PRIMARY KEY,
+  id int IDENTITY PRIMARY KEY,
   name varchar(255) NOT NULL,
   course_id int NOT NULL
 )
 
 CREATE TABLE colnametests (
-  id numeric(9,0) IDENTITY PRIMARY KEY,
+  id int IDENTITY PRIMARY KEY,
   [references] int NOT NULL
 )
 
 CREATE TABLE mixins (
-  id numeric(9,0) IDENTITY PRIMARY KEY,
+  id int IDENTITY PRIMARY KEY,
   parent_id int NULL,
   pos int NULL,
   created_at datetime NULL,
@@ -117,30 +117,30 @@
 )
 
 CREATE TABLE people (
-  id numeric(9,0) IDENTITY PRIMARY KEY,
+  id int IDENTITY PRIMARY KEY,
   first_name varchar(40) NOT NULL,
   lock_version int DEFAULT 0
 )
 
 CREATE TABLE readers (
-    id numeric(9,0) IDENTITY PRIMARY KEY,
+    id int IDENTITY PRIMARY KEY,
     post_id int NOT NULL,
     person_id int NOT NULL
 )
 
 CREATE TABLE binaries (
-  id numeric(9,0) IDENTITY PRIMARY KEY,
+  id int IDENTITY PRIMARY KEY,
   data image NULL
 )
 
 CREATE TABLE computers (
-  id numeric(9,0) IDENTITY PRIMARY KEY,
+  id int IDENTITY PRIMARY KEY,
   developer int NOT NULL,
   extendedWarranty int NOT NULL
 )
 
 CREATE TABLE posts (
-  id numeric(9,0) IDENTITY PRIMARY KEY,
+  id int IDENTITY PRIMARY KEY,
   author_id int NULL,
   title varchar(255) NOT NULL,
   body varchar(2048) NOT NULL,
@@ -148,25 +148,25 @@
 )
 
 CREATE TABLE comments (
-  id numeric(9,0) IDENTITY PRIMARY KEY,
+  id int IDENTITY PRIMARY KEY,
   post_id int NOT NULL,
   body varchar(2048) NOT NULL,
   type varchar(255) NOT NULL
 )
 
 CREATE TABLE authors (
-  id numeric(9,0) IDENTITY PRIMARY KEY,
+  id int IDENTITY PRIMARY KEY,
   name varchar(255) NOT NULL
 )
 
 CREATE TABLE tasks (
-  id numeric(9,0) IDENTITY PRIMARY KEY,
+  id int IDENTITY PRIMARY KEY,
   starting datetime NULL,
   ending datetime NULL
 )
 
 CREATE TABLE categories (
-  id numeric(9,0) IDENTITY PRIMARY KEY,
+  id int IDENTITY PRIMARY KEY,
   name varchar(255) NOT NULL,
   type varchar(255) NOT NULL
 )
@@ -177,25 +177,25 @@
 )
 
 CREATE TABLE fk_test_has_pk (
-  id numeric(9,0) IDENTITY PRIMARY KEY
+  id int IDENTITY PRIMARY KEY
 )
 
 CREATE TABLE fk_test_has_fk (
-  id    numeric(9,0) PRIMARY KEY,
-  fk_id numeric(9,0) NOT NULL,
+  id    int PRIMARY KEY,
+  fk_id int NOT NULL,
 
   FOREIGN KEY (fk_id) REFERENCES fk_test_has_pk(id)
 )
 
 
 CREATE TABLE keyboards (
-  key_number numeric(9,0) IDENTITY PRIMARY KEY,
+  key_number int IDENTITY PRIMARY KEY,
   name varchar(50) NULL
 )
 
 --This table has an altered lock_version column name.
 CREATE TABLE legacy_things (
-  id numeric(9,0) IDENTITY PRIMARY KEY,
+  id int IDENTITY PRIMARY KEY,
   tps_report_number int default NULL,
   version int default 0,
 )
Index: test/migration_test.rb
===================================================================
--- test/migration_test.rb	(revision 1)
+++ test/migration_test.rb	(working copy)
@@ -46,7 +46,14 @@
     end
 
     def test_add_index
-      Person.connection.add_column "people", "last_name", :string        
+      if current_adapter?(:ODBCAdapter) && ActiveRecord::Base.connection.dbmsName == :informix
+        # Index on (last_name, first_name) exceeds max. index width supported by Informix if 
+        # both columns are created with a default width of 255, in which case
+        # Informix may return error -517: "The total size of the index is too large..."        
+        Person.connection.add_column "people", "last_name", :string, {:limit => 40}       
+      else      
+        Person.connection.add_column "people", "last_name", :string       
+      end
       Person.connection.add_column "people", "administrator", :boolean
       Person.connection.add_column "people", "key", :string
       
@@ -61,7 +68,8 @@
       assert_nothing_raised { Person.connection.remove_index("people", :name => "key") }
 
       # Sybase adapter does not support indexes on :boolean columns
-      unless current_adapter?(:SybaseAdapter)
+      unless current_adapter?(:SybaseAdapter) || 
+             current_adapter?(:ODBCAdapter) && ActiveRecord::Base.connection.dbmsName == :sybase
         assert_nothing_raised { Person.connection.add_index("people", %w(last_name first_name administrator), :name => "named_admin") }
         assert_nothing_raised { Person.connection.remove_index("people", :name => "named_admin") }
       end
@@ -109,6 +117,12 @@
         # Oracle doesn't support native booleans
         assert_equal true, two.default == 1
         assert_equal false, three.default != 0
+      elsif current_adapter?(:ODBCAdapter) && 
+          [:informix, :ingres, :virtuoso, :oracle, :mysql, :microsoftsqlserver].include?(ActiveRecord::Base.connection.dbmsName)
+        # Above databases/ODBC drivers don't support native booleans.
+        # They use an integer type instead.
+        assert_equal true, two.default == 1
+        assert_equal false, three.default != 0        
       else
         assert_equal true, two.default
         assert_equal false, three.default
@@ -122,12 +136,14 @@
     # SQL Server and Sybase will not allow you to add a NOT NULL column
     # to a table without specifying a default value, so the
     # following test must be skipped  
-    unless current_adapter?(:SQLServerAdapter) || current_adapter?(:SybaseAdapter)
+    unless current_adapter?(:SQLServerAdapter) || current_adapter?(:SybaseAdapter) ||
+           current_adapter?(:ODBCAdapter) && [:microsoftsqlserver, :sybase].include?(ActiveRecord::Base.connection.dbmsName)
       def test_add_column_not_null_without_default
+
         Person.connection.create_table :testings do |t|
-          t.column :foo, :string
+            t.column :foo, :string
         end
-        Person.connection.add_column :testings, :bar, :string, :null => false
+          Person.connection.add_column :testings, :bar, :string, :null => false
   
         assert_raises(ActiveRecord::StatementInvalid) do
           Person.connection.execute "insert into testings (foo, bar) values ('hello', NULL)"
@@ -141,8 +157,14 @@
       Person.connection.create_table :testings do |t|
         t.column :foo, :string
       end
-      Person.connection.add_column :testings, :bar, :string, :null => false, :default => "default"
-
+      if current_adapter?(:ODBCAdapter) && [:ingres].include?(ActiveRecord::Base.connection.dbmsName)
+        # Ingres requires that if 'ALTER TABLE table ADD column' specifies a NOT NULL constraint,
+        # then 'WITH DEFAULT' must also be specified *without* a default value.        
+        Person.connection.add_column :testings, :bar, :string, :null => false
+      else     
+        Person.connection.add_column :testings, :bar, :string, :null => false, :default => "default"
+      end
+      
       assert_raises(ActiveRecord::StatementInvalid) do
         Person.connection.execute "insert into testings (foo, bar) values ('hello', NULL)"
       end
@@ -174,8 +196,12 @@
       assert_equal Fixnum, bob.age.class
       assert_equal Time, bob.birthday.class
 
-      if current_adapter?(:SQLServerAdapter) || current_adapter?(:OracleAdapter) || current_adapter?(:SybaseAdapter)
-        # SQL Server, Sybase, and Oracle don't differentiate between date/time
+      if current_adapter?(:SQLServerAdapter) || 
+         current_adapter?(:OracleAdapter) || 
+         current_adapter?(:SybaseAdapter) ||
+         (current_adapter?(:ODBCAdapter) && 
+         [:ingres, :oracle, :microsoftsqlserver].include?(ActiveRecord::Base.connection.dbmsName))
+         # SQL Server, Sybase, Oracle and Ingres don't differentiate between date/time
         assert_equal Time, bob.favorite_day.class
       else
         assert_equal Date, bob.favorite_day.class
@@ -186,7 +212,7 @@
 
     def test_add_remove_single_field_using_string_arguments
       assert !Person.column_methods_hash.include?(:last_name)
-
+      
       ActiveRecord::Migration.add_column 'people', 'last_name', :string
 
       Person.reset_column_information
@@ -212,94 +238,130 @@
       assert !Person.column_methods_hash.include?(:last_name)
     end
     
-    def test_add_rename
-      Person.delete_all
-           
-      begin
-        Person.connection.add_column "people", "girlfriend", :string      
-        Person.create :girlfriend => 'bobette'      
-      
-        Person.connection.rename_column "people", "girlfriend", "exgirlfriend"
-      
-        Person.reset_column_information      
-        bob = Person.find(:first)
-      
-        assert_equal "bobette", bob.exgirlfriend
-      ensure
-        Person.connection.remove_column("people", "girlfriend") rescue nil
+    # Ingres, Virtuoso:
+    # Neither supports renaming of columns. Skip test.
+    unless current_adapter?(:ODBCAdapter) && 
+        [:ingres, :virtuoso].include?(ActiveRecord::Base.connection.dbmsName)
+      def test_add_rename
+        Person.delete_all
+        
+        begin
+          # Some DBs complain girlfriend column already exists on two consecutive add_column calls
+          unless current_adapter?(:ODBCAdapter) && [:informix, :oracle, :mysql, :microsoftsqlserver, :sybase].include?(ActiveRecord::Base.connection.dbmsName)        
+            Person.connection.add_column "people", "girlfriend", :string
+          end
+          Person.connection.add_column "people", "girlfriend", :string, :limit => 40
+          Person.create :girlfriend => 'bobette'      
+          
+          Person.connection.rename_column "people", "girlfriend", "exgirlfriend"
+          
+          Person.reset_column_information      
+          bob = Person.find(:first)
+          
+          assert_equal "bobette", bob.exgirlfriend
+        ensure
+          Person.connection.remove_column("people", "girlfriend") rescue nil
         Person.connection.remove_column("people", "exgirlfriend") rescue nil
+        end        
       end
-      
     end
     
-    def test_rename_column_using_symbol_arguments
-      begin
-        Person.connection.rename_column :people, :first_name, :nick_name
-        Person.reset_column_information
-        assert Person.column_names.include?("nick_name")
-      ensure
-        Person.connection.remove_column("people","nick_name")
-        Person.connection.add_column("people","first_name", :string)
+    # Ingres and Virtuoso don't support renaming of columns. Skip test.
+    unless current_adapter?(:ODBCAdapter) && [:ingres, :virtuoso].include?(ActiveRecord::Base.connection.dbmsName)    
+      def test_rename_column_using_symbol_arguments
+        begin
+          Person.connection.rename_column :people, :first_name, :nick_name
+          Person.reset_column_information
+          assert Person.column_names.include?("nick_name")
+        ensure
+          Person.connection.remove_column("people","nick_name")
+          Person.connection.add_column("people","first_name", :string)
+        end
       end
     end
-    
-    def test_rename_column
-      begin
-        Person.connection.rename_column "people", "first_name", "nick_name"
-        Person.reset_column_information
-        assert Person.column_names.include?("nick_name")
-      ensure
-        Person.connection.remove_column("people","nick_name")
-        Person.connection.add_column("people","first_name", :string)
+        
+    # Ingres and Virtuoso don't support renaming of columns. Skip test.
+    unless current_adapter?(:ODBCAdapter) && [:ingres, :virtuoso].include?(ActiveRecord::Base.connection.dbmsName)    
+      def test_rename_column
+        begin
+          Person.connection.rename_column "people", "first_name", "nick_name"
+          Person.reset_column_information
+          assert Person.column_names.include?("nick_name")
+        ensure
+          Person.connection.remove_column("people","nick_name")
+          Person.connection.add_column("people","first_name", :string)
+        end
       end
     end
     
-    def test_rename_table
-      begin
-        ActiveRecord::Base.connection.create_table :octopuses do |t|
-          t.column :url, :string
-        end
-        ActiveRecord::Base.connection.rename_table :octopuses, :octopi
-
-        assert_nothing_raised do
-          if current_adapter?(:OracleAdapter)
-            # Oracle requires the explicit sequence value for the pk
-            ActiveRecord::Base.connection.execute "INSERT INTO octopi (id, url) VALUES (1, 'http://www.foreverflying.com/octopus-black7.jpg')"
-          else
-            ActiveRecord::Base.connection.execute "INSERT INTO octopi (url) VALUES ('http://www.foreverflying.com/octopus-black7.jpg')"
+    # Ingres doesn't support renaming of tables. Skip test.
+    unless current_adapter?(:ODBCAdapter) && [:ingres].include?(ActiveRecord::Base.connection.dbmsName)        
+      def test_rename_table
+        begin
+          ActiveRecord::Base.connection.create_table :octopuses do |t|
+            t.column :url, :string
           end
+          ActiveRecord::Base.connection.rename_table :octopuses, :octopi
+          
+          assert_nothing_raised do
+            if current_adapter?(:OracleAdapter) ||
+               current_adapter?(:ODBCAdapter) && [:oracle].include?(ActiveRecord::Base.connection.dbmsName)
+              # Oracle requires the explicit sequence value for the pk
+              ActiveRecord::Base.connection.execute "INSERT INTO octopi (id, url) VALUES (1, 'http://www.foreverflying.com/octopus-black7.jpg')"
+            else
+              ActiveRecord::Base.connection.execute "INSERT INTO octopi (url) VALUES ('http://www.foreverflying.com/octopus-black7.jpg')"
+            end
+          end
+          
+          assert_equal 'http://www.foreverflying.com/octopus-black7.jpg', ActiveRecord::Base.connection.select_value("SELECT url FROM octopi WHERE id=1")
+          
+        ensure
+          ActiveRecord::Base.connection.drop_table :octopuses rescue nil
+        ActiveRecord::Base.connection.drop_table :octopi rescue nil
         end
-
-        assert_equal 'http://www.foreverflying.com/octopus-black7.jpg', ActiveRecord::Base.connection.select_value("SELECT url FROM octopi WHERE id=1")
-
-      ensure
-        ActiveRecord::Base.connection.drop_table :octopuses rescue nil
-        ActiveRecord::Base.connection.drop_table :octopi rescue nil
       end
     end
 
-    def test_change_column
-      Person.connection.add_column 'people', 'age', :integer
-      old_columns = Person.connection.columns(Person.table_name, "#{name} Columns")
-      assert old_columns.find { |c| c.name == 'age' and c.type == :integer }
+    # Virtuoso disallows virtually all column type conversions.
+    # Conversion between any of the native types used by the ActiveRecord generic types is not allowed.
+    # Skip the test.
+    unless current_adapter?(:ODBCAdapter) && [:virtuoso].include?(ActiveRecord::Base.connection.dbmsName)    
+      def test_change_column
+        #Ingres doesn't support changing an integer column to varchar/text.
+        if current_adapter?(:ODBCAdapter) && [:ingres].include?(ActiveRecord::Base.connection.dbmsName)
+          initial_type = :integer
+          new_type = :float
+        else
+          initial_type = :integer
+          new_type = :string
+        end
+        
+        Person.connection.add_column 'people', 'age', initial_type
+        old_columns = Person.connection.columns(Person.table_name, "#{name} Columns")
+        assert old_columns.find { |c| c.name == 'age' and c.type == initial_type }
+        
+        assert_nothing_raised { Person.connection.change_column "people", "age", new_type }
+        
+        new_columns = Person.connection.columns(Person.table_name, "#{name} Columns")
+        assert_nil new_columns.find { |c| c.name == 'age' and c.type == initial_type }
+        assert new_columns.find { |c| c.name == 'age' and c.type == new_type }
+      end    
+    end
 
-      assert_nothing_raised { Person.connection.change_column "people", "age", :string }
-      
-      new_columns = Person.connection.columns(Person.table_name, "#{name} Columns")
-      assert_nil new_columns.find { |c| c.name == 'age' and c.type == :integer }
-      assert new_columns.find { |c| c.name == 'age' and c.type == :string }
-    end    
-
-    def test_change_column_with_new_default
-      Person.connection.add_column "people", "administrator", :boolean, :default => 1
-      Person.reset_column_information            
-      assert Person.new.administrator?
-      
-      assert_nothing_raised { Person.connection.change_column "people", "administrator", :boolean, :default => 0 }
-      Person.reset_column_information            
-      assert !Person.new.administrator?
-    end    
-
+    # Ingres doesn't support ALTER TABLE ADD COLUMN WITH NULL WITH DEFAULT.
+    # Sybase ASE's ALTER TABLE doesn't support altering a column's DEFAULT definition.
+    unless current_adapter?(:ODBCAdapter) && [:ingres, :sybase].include?(ActiveRecord::Base.connection.dbmsName)    
+      def test_change_column_with_new_default
+        Person.connection.add_column "people", "administrator", :boolean, :default => 1
+        Person.reset_column_information            
+        assert Person.new.administrator?
+        
+        assert_nothing_raised { Person.connection.change_column "people", "administrator", :boolean, :default => 0 }
+        Person.reset_column_information            
+        assert !Person.new.administrator?
+      end    
+    end
+    
     def test_add_table
       assert !Reminder.table_exists?
       
@@ -465,9 +527,20 @@
       Person.connection.drop_table :binary_testings rescue nil
     
       assert_nothing_raised {
+      if current_adapter?(:ODBCAdapter) && [:informix, :ingres].include?(ActiveRecord::Base.connection.dbmsName)
+        # Specifying a non-null default generates the following error:
+        # Informix:
+        #   "Cannot specify non-null default value for blob column. (-594)" 
+        # Ingres:
+        #   "Cannot create a default on column of type 'long byte'"
         Person.connection.create_table :binary_testings do |t|
+          t.column "data", :binary
+        end
+      else
+        Person.connection.create_table :binary_testings do |t|
           t.column "data", :binary, :default => "", :null => false
         end
+      end
       }
       
       columns = Person.connection.columns(:binary_testings)
@@ -475,6 +548,8 @@
 
       if current_adapter?(:OracleAdapter)
         assert_equal "empty_blob()", data_column.default
+      elsif current_adapter?(:ODBCAdapter) && [:informix, :ingres].include?(ActiveRecord::Base.connection.dbmsName)        
+        assert_nil data_column.default
       else
         assert_equal "", data_column.default
       end
